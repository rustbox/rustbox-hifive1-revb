use hifive1::sprintln;

static FONT_OFFSET: u8 = 32;
static FONT: [[u8; 5]; 95] = [
    [0x00, 0x00, 0x00, 0x00, 0x00],     // space
    [0x00, 0x00, 0xfa, 0x00, 0x00],     // !
    [0x00, 0xe0, 0x00, 0xe0, 0x00],     // "
    [0x28, 0xfe, 0x28, 0xfe, 0x28],     // #
    [0x24, 0x52, 0xff, 0x52, 0x4c],     // $
    [0xc4, 0xc8, 0x10, 0x26, 0x46],     // %
    [0x5c, 0xa2, 0x92, 0x4c, 0x0a],     // &
    [0x00, 0x00, 0xe0, 0x00, 0x00],     // '
    [0x00, 0x7c, 0x82, 0x00, 0x00],     // (
    [0x00, 0x00, 0x82, 0x7c, 0x00],     // )
    [0x48, 0x30, 0xfc, 0x30, 0x48],     // *
    [0x08, 0x08, 0x3e, 0x08, 0x08],     // +
    [0x01, 0x07, 0x06, 0x00, 0x00],     // ,
    [0x08, 0x08, 0x08, 0x08, 0x08],     // -
    [0x06, 0x06, 0x00, 0x00, 0x00],     // .
    [0x00, 0x06, 0x38, 0xc0, 0x00],     // /
    [0x7c, 0x8a, 0x92, 0xa2, 0x7c],     // 0
    [0x00, 0x42, 0xfe, 0x02, 0x00],     // 1
    [0x46, 0x8a, 0x92, 0xa2, 0x42],     // 2
    [0x44, 0x82, 0x92, 0x92, 0x6c],     // 3
    [0x18, 0x28, 0x48, 0xfe, 0x08],     // 4
    [0xf4, 0x92, 0x92, 0x92, 0x8c],     // 5
    [0x7c, 0x92, 0x92, 0x92, 0x4c],     // 6
    [0x80, 0x80, 0x8e, 0xb0, 0xc0],     // 7
    [0x6c, 0x92, 0x92, 0x92, 0x6c],     // 8
    [0x60, 0x92, 0x92, 0x92, 0x7c],     // 9
    [0x00, 0x36, 0x36, 0x00, 0x00],     // :
    [0x01, 0x37, 0x36, 0x00, 0x00],     // ;
    [0x08, 0x14, 0x14, 0x22, 0x22],     // <
    [0x14, 0x14, 0x14, 0x14, 0x14],     // =
    [0x22, 0x22, 0x14, 0x14, 0x08],     // >
    [0x40, 0x80, 0x8a, 0x90, 0x60],     // ?
    [0x7e, 0x81, 0x99, 0xa5, 0x7c],     // @
    [0x3e, 0x48, 0x88, 0x48, 0x3e],     // A
    [0xfe, 0x92, 0x92, 0x92, 0x6c],     // B
    [0x7c, 0x82, 0x82, 0x82, 0x44],     // C
    [0xfe, 0x82, 0x82, 0x82, 0x7c],     // D
    [0xfe, 0x92, 0x92, 0x92, 0x82],     // E
    [0xfe, 0x90, 0x90, 0x90, 0x80],     // F
    [0x7c, 0x82, 0x82, 0x8a, 0x4c],     // G
    [0xfe, 0x10, 0x10, 0x10, 0xfe],     // H
    [0x00, 0x82, 0xfe, 0x82, 0x00],     // I
    [0x0c, 0x02, 0x02, 0x02, 0xfc],     // J
    [0xfe, 0x10, 0x28, 0x44, 0x82],     // K
    [0xfe, 0x02, 0x02, 0x02, 0x02],     // L
    [0xfe, 0x40, 0x38, 0x40, 0xfe],     // M
    [0xfe, 0x40, 0x30, 0x08, 0xfe],     // N
    [0x7c, 0x82, 0x82, 0x82, 0x7c],     // O
    [0xfe, 0x90, 0x90, 0x90, 0x60],     // P
    [0x7c, 0x82, 0x82, 0x83, 0x7d],     // Q
    [0xfe, 0x90, 0x90, 0x98, 0x66],     // R
    [0x64, 0x92, 0x92, 0x92, 0x4c],     // S
    [0x80, 0x80, 0xfe, 0x80, 0x80],     // T
    [0xfc, 0x02, 0x02, 0x02, 0xfc],     // U
    [0xf8, 0x04, 0x02, 0x04, 0xf8],     // V
    [0xFc, 0x02, 0x1c, 0x02, 0xFc],     // W
    [0xc6, 0x28, 0x10, 0x28, 0xc6],     // X
    [0xc0, 0x20, 0x1e, 0x20, 0xc0],     // Y
    [0x86, 0x8a, 0x92, 0xa2, 0xc2],     // Z
    [0x00, 0xfe, 0x82, 0x00, 0x00],     // [
    [0x00, 0xc0, 0x38, 0x06, 0x00],     // \
    [0x00, 0x82, 0xfe, 0x00, 0x00],     // ]
    [0x10, 0x20, 0x40, 0x20, 0x10],     // ^
    [0x01, 0x01, 0x01, 0x01, 0x01],     // _
    [0x00, 0x80, 0xc0, 0x40, 0x00],     // `
    [0x0c, 0x52, 0x52, 0x52, 0x3e],     // a
    [0xfe, 0x22, 0x22, 0x22, 0x1c],     // b
    [0x1c, 0x22, 0x22, 0x22, 0x00],     // c
    [0x1c, 0x22, 0x22, 0x22, 0xfe],     // d
    [0x1c, 0x2a, 0x2a, 0x2a, 0x1a],     // e
    [0x00, 0x10, 0x7e, 0x90, 0x40],     // f
    [0x18, 0x25, 0x25, 0x25, 0x3e],     // g
    [0xfe, 0x10, 0x10, 0x10, 0x0e],     // h
    [0x00, 0x00, 0x2e, 0x00, 0x00],     // i
    [0x00, 0x01, 0x11, 0x5e, 0x00],     // j
    [0xfe, 0x08, 0x14, 0x22, 0x00],     // k
    [0x00, 0x00, 0xfe, 0x00, 0x00],     // l
    [0x3e, 0x20, 0x1c, 0x20, 0x3e],     // m
    [0x3e, 0x10, 0x20, 0x20, 0x1e],     // n
    [0x1c, 0x22, 0x22, 0x22, 0x1c],     // o
    [0x3f, 0x24, 0x24, 0x24, 0x18],     // p
    [0x18, 0x24, 0x24, 0x24, 0x3f],     // q
    [0x00, 0x3e, 0x10, 0x20, 0x20],     // r
    [0x12, 0x2a, 0x2a, 0x2a, 0x24],     // s
    [0x20, 0xfc, 0x22, 0x22, 0x04],     // t
    [0x3c, 0x02, 0x02, 0x02, 0x3c],     // u
    [0x30, 0x0c, 0x02, 0x0c, 0x30],     // v
    [0x3c, 0x02, 0x0c, 0x02, 0x3c],     // w
    [0x22, 0x14, 0x08, 0x14, 0x22],     // x
    [0x38, 0x05, 0x05, 0x05, 0x3e],     // y
    [0x22, 0x26, 0x2a, 0x32, 0x22],     // z
    [0x00, 0x10, 0x6c, 0x82, 0x00],     // {
    [0x00, 0x00, 0xff, 0x00, 0x00],     // |
    [0x00, 0x82, 0x6c, 0x10, 0x00],     // }
    [0x10, 0x20, 0x10, 0x08, 0x10],     // ~
];

static DEFAULT_FONT: [u8; 5] = [0xfe, 0x82, 0x82, 0x82, 0xfe];

static COLOR_MAP: [u8; 16] = [
    0x00,       // Black
    0x30,       // Blue
    0x0c,       // Green
    0x3c,       // Cyan / Light Blue
    0x03,       // Red
    0x33,       // Purple
    0x07,       // Brown
    0x2a,       // Grey
    0x15,       // Dark Grey
    0x35,       // Light Blue
    0x1d,       // Light Green
    0x3d,       // Light Cyan
    0x17,       // Light Red (pink?)
    0x37,       // Light Purple
    0x1f,       // Yellow
    0x3f,       // White
];

pub const COLUMNS: usize = 21;
pub const ROWS: usize = 10;

#[derive(Clone, Copy, Debug)]
pub enum PixelState {
    On(usize),
    Off(usize)
}

pub struct CharVis {
    chr: char,
    reverse: bool,
    foreground: u8,
    background: u8,
}

impl CharVis {
    pub const fn new(c: char, foreground: u8, background: u8) -> CharVis {
        CharVis { chr: c, reverse: false,  foreground, background }
    }

    pub fn reverse(&mut self) {
        self.reverse = true;
    }

    pub fn normal(&mut self) {
        self.reverse = false;
    }

    pub fn draw(&self, buffer: &mut [u8], col: usize, row: usize) {
        let pxs = char_font(col, row, self.chr, self.reverse);
        for p in pxs {
            match p {
                PixelState::On(addr) => {
                    buffer[addr] = self.foreground;
                },
                PixelState::Off(addr) => {
                    buffer[addr] = self.background;
                }
            }
        }
        for y in 0..9 {
            let p = pixel_from_cell_offset(col, row, 5, y);
            buffer[p] = if self.reverse { self.foreground } else { self.background };
        }
        for x in 0..6 {
            let p = pixel_from_cell_offset(col, row, x, 8);
            buffer[p] = if self.reverse { self.foreground } else { self.background };
        }
    }

    pub fn toggle_reverse(&mut self) {
        self.reverse = !self.reverse;
    }
}

impl From<char> for CharVis {
    fn from(c: char) -> CharVis {
        CharVis::new(c, 0xff, 0x00)
    }
}

impl From<u16> for CharVis {
    fn from(hw: u16) -> CharVis {
        let c = (hw & 0x007F) as u8;
        let reverse = (hw & 0x80) != 0;
        let colors = (hw >> 8) as u8;
        let fore = COLOR_MAP[(colors & 0x0f) as usize];
        let back = COLOR_MAP[(colors >> 4) as usize];
        CharVis { chr: c as char, reverse, foreground: fore, background: back }
    }
}

pub fn draw_text(text: &str, buffer: &mut [u8], row: usize, foreground: u8, background: u8) {
    text.chars().enumerate().for_each(|(i, t)| {
        let c = CharVis::new(t, foreground, background);
        c.draw(buffer, i, row);
    })
}

pub fn draw_reverse(text: &str, buffer: &mut [u8], row: usize, foreground: u8, background: u8) {
    text.chars().enumerate().for_each(|(i, t)| {
        let mut c = CharVis::new(t, foreground, background);
        c.reverse();
        c.draw(buffer, i, row);
    })
}

fn cell_start(col: usize, row: usize) -> usize {
    let c = col.clamp(0, COLUMNS);
    let r = row.clamp(0, ROWS);
    6*c + 9*crate::WIDTH*r
}

pub fn pixel_from_cell_offset(col: usize, row: usize, offx: usize, offy: usize) -> usize {
    let start = cell_start(col, row);
    start + crate::WIDTH*offy + offx
}

/// list of pixel locations to be turned on and off
fn pixel_list(col: usize, row: usize, char_font: [u8; 5]) -> [PixelState; 40] {
    let mut charbmp = [PixelState::Off(0); 40];
    for offx in 0..5 {
        for offy in 0..8 {
            let p = pixel_from_cell_offset(col, row, offx, offy);
            let k = 7 - offy;
            if char_font[offx] & 1 << k != 0 {
                charbmp[offy + 8*offx] = PixelState::On(p);
            } else {
                charbmp[offy + 8*offx] = PixelState::Off(p);
            }
        }
    }
    charbmp
}

pub fn char_font(col: usize, row: usize, c: char, rev: bool) -> [PixelState; 40] {
    if c as u8 >= FONT_OFFSET && (c as u8) < 127 {
        let char_val = c as usize - FONT_OFFSET as usize;
        let f = if !rev {
            FONT[char_val]
        } else {
            reverse(&FONT[char_val])
        };
        pixel_list(col, row, f)
    } else {
        let f = if !rev {
            DEFAULT_FONT
        } else {
            reverse(&DEFAULT_FONT)
        };
        pixel_list(col, row, f)
    }
}

pub fn reverse(font: &[u8; 5]) -> [u8; 5] {
    let mut rev = [0; 5];
    for r in 0..font.len() {
        rev[r] = !font[r];
    }
    rev
}
